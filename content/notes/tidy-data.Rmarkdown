---
title: "Tidy data"
date: 2019-03-01

type: docs
toc: true
draft: false
aliases: ["/datawrangle_tidy_data.html"]
categories: ["datawrangle"]

menu:
  notes:
    parent: Data wrangling
    weight: 7
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

```{r packages, cache = FALSE, message = FALSE}
library(tidyverse)
```

Most data analysts and statisticians analyze data in a spreadsheet or tabular format. This is not the only way to store information,^[Computer scientists and web developers frequently make use of a range of other data types to store information.] however in the social sciences it has been the paradigm for many decades. **Tidy data** is a specific way of organizing data into a consistent format which plugs into the `tidyverse` set of packages for R. It is not the only way to store data and there are reasons why you might not store data in this format, but eventually you will probably need to convert your data to a tidy format in order to efficiently analyze it.

There are three rules which make a dataset **tidy**:

1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

![Figure 12.1 from [*R for Data Science*](http://r4ds.had.co.nz)](https://r4ds.had.co.nz/images/tidy-1.png)

## Traditional functions in `tidyr`

Let's review the different tasks for tidying data using the R for Data Science `gapminder` subset. This is the data in a tidy format:

```{r tidy}
table1
```

Note that in this data frame, each variable is in its own column (`country`, `year`, `cases`, and `population`), each observation is in its own row (i.e. each row is a different country-year pairing), and each value has its own cell.

## Gathering

**Gathering** entails bringing a variable spread across multiple columns into a single column. For example, this version of `table1` is not tidy because the `year` variable is spread across multiple columns:

```{r spread-columns}
table4a
```

We can use the `gather()` function from the `tidyr` package to reshape the data frame and make this tidy. To do this we need three pieces of information:

1. The names of the columns that represent the values, not variables. Here, those are `1999` and `2000`.
1. The `key`, or the name of the variable whose values form the column names. Here that is `year`.
1. The `value`, or the name of the variable whose values are spread over the cells. Here that is `cases`. 

> Notice that we create the names for `key` and `value` - they do not already exist in the data frame.

We implement this using the `gather()` function:

```{r gather}
table4a %>% 
  gather(key = year, value = cases, `1999`, `2000`)
```

> In Stata and other statistics software, this operation would be called reshaping data wide to long.

## Spreading

**Spreading** brings an observation spread across multiple rows into a single row. It is the reverse of gathering. For instance, take `table2`:

```{r spread-rows}
table2
```

It violates the tidy data principle because each observation (unit of analysis is a country-year pairing) is split across multiple rows. To tidy the data frame, we need to know:

1. The `key` column, or the column that contains variable names. Here, it is `type`.
1. The `value` column, or the column that contains values for multiple variables. Here it is `count`.

> Notice that unlike for gathering, when spreading the `key` and `value` columns are already defined in the data frame. We do not create the names ourselves, only identify them in the existing data frame.

```{r spread}
table2 %>%
  spread(key = type, value = count)
```

> In Stata and other statistics software, this operation would be called reshaping data long to wide.

## Separating

**Separating** splits multiple variables stored in a single column into multiple columns. For example in `table3`, the `rate` column contains both `cases` and `population`:

```{r merged-columns}
table3
```

**This is a no-no**. Tidy data principles require each column to contain a single variable. We can use the `separate()` function to split the column into two new columns:

```{r separate}
table3 %>% 
  separate(col = rate, into = c("cases", "population"))
```

## Uniting

**Uniting** is the inverse of separating - when a variable is stored in multiple columns, uniting brings the variable back into a single column. `table5` splits the year variable into two columns:

```{r split-columns}
table5
```

To bring them back together, use the `unite()` function:

```{r unite}
table5 %>% 
  unite(col = new, century, year)

# remove underscore
table5 %>% 
  unite(col = new, century, year, sep = "")
```

## A modern approach to pivoting

`tidyr` 1.0.0 introduces [a new method for tidying data frames through the use of the `pivot_longer()` and `pivot_wider()` functions](https://tidyr.tidyverse.org/articles/pivot.html). They are intended as successor function to `gather()` and `spread()`; while `gather()` and `spread()` will continue to exist in the `tidyr` package, `pivot_*()` is designed to be more intuitive and straightforward as to their purposes and function arguments.

## `pivot_longer()`

`pivot_longer()` makes datasets **longer** by increasing the number of rows and decreasing the number of columns. Many datasets you obtain are optimized for ease of data entry or ease of comparison rather than ease of analysis. This means data is typically stored messy with more columns than necessary.

For example, consider how we tidied `table4a` previously:

```{r gather}
```

We can now use `pivot_longer()` to perform this operation:

```{r pivot-longer}
table4a %>%
  pivot_longer(cols = -country, names_to = "year", values_to = "cases")
```

The output is the same for both approaches. Neither the `names_to` nor the `values_to` column exists in `table4a`, so we provide them as character strings surrounded in quotes.

## `pivot_wider()`

`pivot_wider()` is the opposite of `pivot_longer()`: it makes a dataset **wider** by increasing the number of columns and decreasing the number of rows. It is analogous to the `spread()` function. If we want to tidy `table2`, the old method is:

```{r spread}
```

Whereas we can use `pivot_wider()`:

```{r pivot-wider}
table2 %>%
  pivot_wider(names_from = type, values_from = count)
```

Since `type` and `count` are already columns that exist in `table2`, we don't have to write them as character strings inside quotation marks.

## Session Info

```{r child = here::here("R", "_session-info.Rmd")}
```
